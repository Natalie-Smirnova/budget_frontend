import { idOf } from '@antv/g6';
import React from 'react';
import { CollapseExpandIcon, RCNode } from '../../core/base';
import { measureTextSize } from '../../core/utils/measure-text';
import { getNodeSide } from '../../core/utils/node';
import { getBoxedTextNodeStyle, getLinearTextNodeStyle } from '../../core/utils/tree';
const { ArrowCountIcon } = CollapseExpandIcon;
const { TextNode } = RCNode;
export const DEFAULT_OPTIONS = {
    node: {
        type: 'react',
        style: {
            component: (data) => React.createElement(TextNode, { type: "filled", text: idOf(data) }),
            size: (data) => measureTextSize(idOf(data), [24, 16]),
            dx: function (data) {
                const side = getNodeSide(this, data);
                const size = measureTextSize(idOf(data), [24, 16]);
                return side === 'left' ? -size[0] : side === 'center' ? -size[0] / 2 : 0;
            },
            ports: [{ placement: 'left' }, { placement: 'right' }],
        },
        state: {
            active: {
                halo: false,
            },
            selected: {
                halo: false,
            },
        },
    },
    edge: {
        type: 'cubic-horizontal',
        style: {
            lineWidth: 3,
        },
    },
    transforms: (prev) => [
        ...prev,
        {
            type: 'collapse-expand-react-node',
            key: 'collapse-expand-react-node',
            enable: false,
            trigger: 'icon',
            iconRender: function (isCollapsed, data) {
                const side = getNodeSide(this, data);
                return (React.createElement(ArrowCountIcon, { graph: this, data: data, isCollapsed: isCollapsed, placement: side === 'left' ? 'left' : 'right' }));
            },
            iconPlacement: function (data) {
                const side = getNodeSide(this, data);
                return side === 'left' ? 'left' : 'right';
            },
        },
    ],
    layout: {
        type: 'mindmap',
        direction: 'H',
        getWidth: (data) => 120,
        getHeight: (data) => measureTextSize(data.id, [24, 16])[1],
        getHGap: () => 64,
    },
    animation: {
        duration: 500,
    },
};
export function getMindMapOptions({ type, direction, nodeMinWidth, nodeMaxWidth, }) {
    let options = {};
    if (type === 'boxed') {
        const minWidth = nodeMinWidth || 120;
        const maxWidth = nodeMaxWidth || 300;
        options = {
            node: {
                style: {
                    component: (data) => {
                        const depth = data.depth;
                        const color = data.style?.color;
                        const props = {
                            text: idOf(data),
                            color,
                            maxWidth,
                            font: getBoxedTextNodeStyle(idOf(data), minWidth, maxWidth, depth).font,
                        };
                        Object.assign(props, depth === 0
                            ? { type: 'filled', color: '#f1f4f5', style: { color: '#252525' } }
                            : depth === 1
                                ? { type: 'filled' }
                                : { type: 'outlined' });
                        return React.createElement(TextNode, { ...props });
                    },
                    size: (data) => getBoxedTextNodeStyle(idOf(data), minWidth, maxWidth, data.depth).size,
                    dx: function (data) {
                        const side = getNodeSide(this, data);
                        const size = getBoxedTextNodeStyle(idOf(data), minWidth, maxWidth, data.depth).size;
                        return side === 'left' ? -size[0] : side === 'center' ? -size[0] / 2 : 0;
                    },
                    ports: [{ placement: 'left' }, { placement: 'right' }],
                },
            },
            edge: {
                style: {
                    stroke: function (data) {
                        return this.getNodeData(data.source).style.color || '#99ADD1';
                    },
                },
            },
            transforms: (prev) => [
                ...prev,
                {
                    type: 'assign-color-by-branch',
                    key: 'assign-color-by-branch',
                },
            ],
            layout: {
                type: 'mindmap',
                getHeight: (data) => getBoxedTextNodeStyle(idOf(data), minWidth, maxWidth, data.depth).size[1],
                getVGap: () => 14,
            },
        };
    }
    else if (type === 'linear') {
        const minWidth = nodeMinWidth || 0;
        const maxWidth = nodeMaxWidth || 300;
        options = {
            node: {
                style: {
                    component: function (data) {
                        const side = getNodeSide(this, data);
                        const depth = data.depth;
                        const color = data.style?.color;
                        const { font } = getLinearTextNodeStyle(idOf(data), minWidth, maxWidth, depth);
                        const props = { text: idOf(data), color, maxWidth, font };
                        Object.assign(props, depth === 0
                            ? { type: 'filled', color: '#f1f4f5', style: { color: '#252525' } }
                            : {
                                type: 'underlined',
                                style: side === 'left' ? { textAlign: 'right' } : side === 'center' ? { textAlign: 'center' } : {},
                            });
                        return React.createElement(TextNode, { ...props });
                    },
                    size: (data) => getLinearTextNodeStyle(idOf(data), minWidth, maxWidth, data.depth).size,
                    dx: function (data) {
                        const side = getNodeSide(this, data);
                        const size = getLinearTextNodeStyle(idOf(data), minWidth, maxWidth, data.depth).size;
                        return side === 'left' ? -size[0] : side === 'center' ? -size[0] / 2 : 0;
                    },
                    ports: function (data) {
                        const side = getNodeSide(this, data);
                        return side === 'center'
                            ? [{ placement: 'left' }, { placement: 'right' }]
                            : [{ placement: 'left-bottom' }, { placement: 'right-bottom' }];
                    },
                },
            },
            edge: {
                style: {
                    stroke: function (data) {
                        return this.getNodeData(data.target).style.color || '#99ADD1';
                    },
                },
            },
            layout: {
                type: 'mindmap',
                getHeight: (data) => getLinearTextNodeStyle(idOf(data), minWidth, maxWidth, data.depth).size[1],
                getVGap: () => 12,
            },
            transforms: (prev) => [
                ...prev.filter((t) => t.key !== 'collapse-expand-react-node'),
                {
                    type: 'assign-color-by-branch',
                    key: 'assign-color-by-branch',
                },
                {
                    ...prev.find((t) => t.key === 'collapse-expand-react-node'),
                    iconOffsetY: (data) => {
                        if (data.depth === 0)
                            return 0;
                        const size = getLinearTextNodeStyle(idOf(data), minWidth, maxWidth, data.depth).size;
                        return size[1] / 2;
                    },
                },
            ],
        };
    }
    if (direction) {
        options.layout ||= {};
        options.layout.direction = direction === 'alternate' ? 'H' : direction === 'left' ? 'RL' : 'LR';
    }
    return options;
}
