"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_OPTIONS = void 0;
exports.getMindMapOptions = getMindMapOptions;
const g6_1 = require("@antv/g6");
const react_1 = __importDefault(require("react"));
const base_1 = require("../../core/base");
const measure_text_1 = require("../../core/utils/measure-text");
const node_1 = require("../../core/utils/node");
const tree_1 = require("../../core/utils/tree");
const { ArrowCountIcon } = base_1.CollapseExpandIcon;
const { TextNode } = base_1.RCNode;
exports.DEFAULT_OPTIONS = {
    node: {
        type: 'react',
        style: {
            component: (data) => react_1.default.createElement(TextNode, { type: "filled", text: (0, g6_1.idOf)(data) }),
            size: (data) => (0, measure_text_1.measureTextSize)((0, g6_1.idOf)(data), [24, 16]),
            dx: function (data) {
                const side = (0, node_1.getNodeSide)(this, data);
                const size = (0, measure_text_1.measureTextSize)((0, g6_1.idOf)(data), [24, 16]);
                return side === 'left' ? -size[0] : side === 'center' ? -size[0] / 2 : 0;
            },
            ports: [{ placement: 'left' }, { placement: 'right' }],
        },
        state: {
            active: {
                halo: false,
            },
            selected: {
                halo: false,
            },
        },
    },
    edge: {
        type: 'cubic-horizontal',
        style: {
            lineWidth: 3,
        },
    },
    transforms: (prev) => [
        ...prev,
        {
            type: 'collapse-expand-react-node',
            key: 'collapse-expand-react-node',
            enable: false,
            trigger: 'icon',
            iconRender: function (isCollapsed, data) {
                const side = (0, node_1.getNodeSide)(this, data);
                return (react_1.default.createElement(ArrowCountIcon, { graph: this, data: data, isCollapsed: isCollapsed, placement: side === 'left' ? 'left' : 'right' }));
            },
            iconPlacement: function (data) {
                const side = (0, node_1.getNodeSide)(this, data);
                return side === 'left' ? 'left' : 'right';
            },
        },
    ],
    layout: {
        type: 'mindmap',
        direction: 'H',
        getWidth: (data) => 120,
        getHeight: (data) => (0, measure_text_1.measureTextSize)(data.id, [24, 16])[1],
        getHGap: () => 64,
    },
    animation: {
        duration: 500,
    },
};
function getMindMapOptions({ type, direction, nodeMinWidth, nodeMaxWidth, }) {
    let options = {};
    if (type === 'boxed') {
        const minWidth = nodeMinWidth || 120;
        const maxWidth = nodeMaxWidth || 300;
        options = {
            node: {
                style: {
                    component: (data) => {
                        const depth = data.depth;
                        const color = data.style?.color;
                        const props = {
                            text: (0, g6_1.idOf)(data),
                            color,
                            maxWidth,
                            font: (0, tree_1.getBoxedTextNodeStyle)((0, g6_1.idOf)(data), minWidth, maxWidth, depth).font,
                        };
                        Object.assign(props, depth === 0
                            ? { type: 'filled', color: '#f1f4f5', style: { color: '#252525' } }
                            : depth === 1
                                ? { type: 'filled' }
                                : { type: 'outlined' });
                        return react_1.default.createElement(TextNode, { ...props });
                    },
                    size: (data) => (0, tree_1.getBoxedTextNodeStyle)((0, g6_1.idOf)(data), minWidth, maxWidth, data.depth).size,
                    dx: function (data) {
                        const side = (0, node_1.getNodeSide)(this, data);
                        const size = (0, tree_1.getBoxedTextNodeStyle)((0, g6_1.idOf)(data), minWidth, maxWidth, data.depth).size;
                        return side === 'left' ? -size[0] : side === 'center' ? -size[0] / 2 : 0;
                    },
                    ports: [{ placement: 'left' }, { placement: 'right' }],
                },
            },
            edge: {
                style: {
                    stroke: function (data) {
                        return this.getNodeData(data.source).style.color || '#99ADD1';
                    },
                },
            },
            transforms: (prev) => [
                ...prev,
                {
                    type: 'assign-color-by-branch',
                    key: 'assign-color-by-branch',
                },
            ],
            layout: {
                type: 'mindmap',
                getHeight: (data) => (0, tree_1.getBoxedTextNodeStyle)((0, g6_1.idOf)(data), minWidth, maxWidth, data.depth).size[1],
                getVGap: () => 14,
            },
        };
    }
    else if (type === 'linear') {
        const minWidth = nodeMinWidth || 0;
        const maxWidth = nodeMaxWidth || 300;
        options = {
            node: {
                style: {
                    component: function (data) {
                        const side = (0, node_1.getNodeSide)(this, data);
                        const depth = data.depth;
                        const color = data.style?.color;
                        const { font } = (0, tree_1.getLinearTextNodeStyle)((0, g6_1.idOf)(data), minWidth, maxWidth, depth);
                        const props = { text: (0, g6_1.idOf)(data), color, maxWidth, font };
                        Object.assign(props, depth === 0
                            ? { type: 'filled', color: '#f1f4f5', style: { color: '#252525' } }
                            : {
                                type: 'underlined',
                                style: side === 'left' ? { textAlign: 'right' } : side === 'center' ? { textAlign: 'center' } : {},
                            });
                        return react_1.default.createElement(TextNode, { ...props });
                    },
                    size: (data) => (0, tree_1.getLinearTextNodeStyle)((0, g6_1.idOf)(data), minWidth, maxWidth, data.depth).size,
                    dx: function (data) {
                        const side = (0, node_1.getNodeSide)(this, data);
                        const size = (0, tree_1.getLinearTextNodeStyle)((0, g6_1.idOf)(data), minWidth, maxWidth, data.depth).size;
                        return side === 'left' ? -size[0] : side === 'center' ? -size[0] / 2 : 0;
                    },
                    ports: function (data) {
                        const side = (0, node_1.getNodeSide)(this, data);
                        return side === 'center'
                            ? [{ placement: 'left' }, { placement: 'right' }]
                            : [{ placement: 'left-bottom' }, { placement: 'right-bottom' }];
                    },
                },
            },
            edge: {
                style: {
                    stroke: function (data) {
                        return this.getNodeData(data.target).style.color || '#99ADD1';
                    },
                },
            },
            layout: {
                type: 'mindmap',
                getHeight: (data) => (0, tree_1.getLinearTextNodeStyle)((0, g6_1.idOf)(data), minWidth, maxWidth, data.depth).size[1],
                getVGap: () => 12,
            },
            transforms: (prev) => [
                ...prev.filter((t) => t.key !== 'collapse-expand-react-node'),
                {
                    type: 'assign-color-by-branch',
                    key: 'assign-color-by-branch',
                },
                {
                    ...prev.find((t) => t.key === 'collapse-expand-react-node'),
                    iconOffsetY: (data) => {
                        if (data.depth === 0)
                            return 0;
                        const size = (0, tree_1.getLinearTextNodeStyle)((0, g6_1.idOf)(data), minWidth, maxWidth, data.depth).size;
                        return size[1] / 2;
                    },
                },
            ],
        };
    }
    if (direction) {
        options.layout ||= {};
        options.layout.direction = direction === 'alternate' ? 'H' : direction === 'left' ? 'RL' : 'LR';
    }
    return options;
}
